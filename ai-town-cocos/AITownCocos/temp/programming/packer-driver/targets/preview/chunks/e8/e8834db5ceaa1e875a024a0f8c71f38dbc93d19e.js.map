{"version":3,"sources":["file:///Users/feiwang/AITown/AITownCocos/assets/src/NPC/AStar.ts"],"names":["_decorator","Component","TiledMap","Vec2","AStarStep","ccclass","property","AStar","_open","_closed","_layerBarrier","start","map","getLayer","update","deltaTime","_indexOfStepArray","value","stepArray","i","length","equals","position","_insertToOpen","step","stepF","f","splice","moveToward","finish","paths","push","pathFound","currentStep","shift","tmpStep","unshift","last","borderPositions","_borderMovablePoints","borderPosition","moveCost","_costToMove","index","g","distancePoint","x","y","h","Math","abs","positionLeft","positionRight","results","hasTop","hasBottom","hasLeft","hasRight","top","getTileGIDAt","bottom","layerSize","height","left","right","width"],"mappings":"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","sourcesContent":["import { _decorator, Component, Node, TiledLayer, TiledMap, Vec2 } from 'cc';\nimport { AStarStep } from './AStarStep'\nconst { ccclass, property } = _decorator;\n\n@ccclass('AStar')\nexport class AStar extends Component {\n\n    @property(TiledMap)\n    public map:TiledMap = null;\n\n    _open = [];\n    _closed = [];\n    _layerBarrier: TiledLayer\n\n    start() {\n        this._layerBarrier = this.map.getLayer('building');\n    }\n\n    update(deltaTime: number) {\n        \n    }\n    \n    _indexOfStepArray(value, stepArray) {\n        for (let i = 0; i < stepArray.length; ++i) {\n            if (value.equals(stepArray[i].position)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    \n    _insertToOpen(step) {\n        let stepF = step.f;\n        let length = this._open.length;\n        let i = 0;\n        for (; i < length; ++i) {\n            if (stepF <= this._open[i].f) {\n                break;\n            }\n        }\n        // insert to index i\n        this._open.splice(i, 0, step);\n    }\n    \n    moveToward(start, finish) {\n        this._closed = [];\n        this._open = [];\n        let paths = [];\n        \n        // cc.log('find start: ' + start + ' to: ' + finish);\n        this._open.push(new AStarStep(start));\n        let pathFound = false;\n        do {\n            // cc.log('==============================================================');\n            let currentStep = this._open.shift();\n            // cc.log('currentStep: ' + currentStep);\n            \n            this._closed.push(currentStep);\n            \n            if (currentStep.position.equals(finish)) {\n                // cc.log('finish :P');\n                pathFound = true;\n                let tmpStep = currentStep;\n                do {  \n                    paths.unshift(tmpStep.position);\n                    tmpStep = tmpStep.last;\n                } while (tmpStep !== null);\n                \n                this._open = [];\n                this._closed = [];\n                break;\n            }\n            \n            let borderPositions = this._borderMovablePoints(currentStep.position);\n            \n            for (let i = 0; i < borderPositions.length; ++i) {\n                let borderPosition = borderPositions[i];\n                // cc.log('check: ' + borderPosition);\n                // Check if the step isn't already in the closed set\n                if (this._indexOfStepArray(borderPosition, this._closed) != -1) {\n                    // cc.log('had in closed: ' + borderPosition);\n                    // cc.log('remove check position: ' + borderPosition);\n                    borderPositions.splice(i, 1);\n                    i--;\n                    continue;\n                }\n                \n                let step = new AStarStep(borderPosition);\n                let moveCost = this._costToMove(borderPosition, finish)\n                let index = this._indexOfStepArray(borderPosition, this._open);\n                \n                if (index == -1) {\n                    step.last = currentStep;\n                    step.g = currentStep.g + moveCost;\n                    let distancePoint = new Vec2(borderPosition.x - finish.x, borderPosition.y - finish.y)\n                    step.h = Math.abs(distancePoint.x) + Math.abs(distancePoint.y);\n                    this._insertToOpen(step);\n                } else {\n                    // cc.log('had in open: ' + step.toString());\n                    step = this._open[index];\n                    if (currentStep.g + moveCost < step.g) {\n                        // cc.log('re insert into open: ' + step.toString());\n                        step.g = currentStep.g + moveCost;\n                        \n                        // re insert\n                        this._open.splice(index, 1);\n                        this._insertToOpen(step);\n                    }\n                }\n            }\n        } while (this._open.length > 0);\n        \n        return paths;\n    }\n    \n    _costToMove(positionLeft, positionRight) {\n        return 1\n        // if (this.moveType == AStarMoveType.EIGHT_DIRECTION) {\n        //     /**\n        //      * diagonal length: 1.41 ≈ Math.sqrt(x * x + y * y)\n        //      * line length: 1\n        //      * \n        //      * cost = length * 10\n        //      * diagonal cost = 14 ≈ 14.1\n        //      * cost line = 10 = 1 * 10\n        //      */\n        //     return (positionLeft.x != positionRight.x) && (positionLeft.y != positionRight.y) ? 14 : 10;\n        // } else {\n        //     return 1;\n        // }\n    }\n    \n    _borderMovablePoints(position) {\n        var results = [];\n        let hasTop = false;\n        let hasBottom = false;\n        let hasLeft = false;\n        let hasRight = false;\n        \n        // top\n        let top = new Vec2(position.x, position.y - 1);\n        if (top.y >= 0 && this._layerBarrier.getTileGIDAt(top.x, top.y) === 0) {\n            // cc.log('top: ' + top);\n            results.push(top);\n            hasTop = true;\n        }\n        // bottom\n        let bottom = new Vec2(position.x, position.y + 1);\n        if (bottom.y < this._layerBarrier.layerSize.height && this._layerBarrier.getTileGIDAt(bottom.x, bottom.y) === 0) {\n            // cc.log('bottom: ' + bottom);\n            results.push(bottom);\n            hasBottom = true;\n        }\n        // left\n        let left = new Vec2(position.x - 1, position.y);\n        if (left.x >= 0 && this._layerBarrier.getTileGIDAt(left.x, left.y) === 0) {\n            // cc.log('left: ' + left);\n            results.push(left);\n            hasLeft = true;\n        }\n        // right\n        let right = new Vec2(position.x + 1, position.y);\n        if (right.x < this._layerBarrier.layerSize.width && this._layerBarrier.getTileGIDAt(right.x, right.y) === 0) {\n            // cc.log('right: ' + right);\n            results.push(right);\n            hasRight = true;\n        }\n        return results;\n    }\n}\n\n"]}